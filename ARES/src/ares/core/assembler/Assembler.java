package ares.core.assembler;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;

import ares.core.InstructionSet;
import ares.core.Memory;
import static ares.core.assembler.AssemblerError.ErrorID;


public class Assembler {
	
	private static int currentSeg = 4;
	private static boolean[] segComplete = new boolean[5];
	
	/**
	 * The symbol/constant table.
	 * Associates a label (the String key) with the value of the appropriate location counter.
	 * Because the different location counters are interpreted differently (see below),
	 * it is necessary to identify which LC is being stored; hence the int[]. 
	 * All values have dimension 2:
	 * 		value[0] = the value of the LC or the constant.
	 * 		value[1] = the LC's segment ID (0-3) or 4 (value[0] is a constant).
	 */
	private HashMap<String, Integer> symTbl = new HashMap<>();
	
	/**
	 * The set of location counters: one for each segment.
	 * Note that they each mean something different: 
	 * 	The data/kdata LC keeps track of the current byte number.
	 * 	The text/ktext LC keeps track of the current instruction!
	 * 
	 */
	private int[] LC = {0, 0, 0, 0};
	
	/**
	 * Storage for the assembled segments, which are represented
	 * as ArrayLists of Bytes.
	 */
	
	private ArrayList<ArrayList<Byte>> dataSegs = new ArrayList<>(4);

	
	private LinkedList<String> tokenizedSource;
	
	public Assembler(LinkedList<String> tokenizedSource)
	{
		this.tokenizedSource = tokenizedSource;
		for(int i = 0; i < 4; i++)
			dataSegs.add(new ArrayList<Byte>());
	}
	
	/**
	 * Complete the first of two passes in assembling the program.
	 * The four tasks this method accomplishes, in order of implementation, are:
	 * 	1. Builds the symbol table for the entire program.
	 * 	2. Assembles the data and kernel data segments.
	 * 	3. Expands pseudoinstructions.
	 * 	4. Parses macros and adds them to the pseudoinstruction set.
	 * 	5. Parses other assembler directives.
	 * 
	 * Assembly of the data segment--indeed, assembly of any kind--is not undertaken 
	 * in the first pass of the canonical two-pass assembler. Nevertheless, building the
	 * symbol table requires foreknowledge of the exact size in bytes of each directive or instruction;
	 * to do this, each directive in the data segment needs to be processed. (There is NO constant-size
	 * data segment directive--even .byte and .word may be followed by any number of data.)
	 * 
	 * The tokenized source is modified by this method: everything the second pass does not need is removed.
	 * Since the tokenized source is a linked list, this is done by adding a sentinel node (null), popping each token.
	 * and then enqueing it back onto the end.
	 * 
	 * @param tokenizedSource LinkedList<String> generated by Tokenizer
	 * @throws AssemblerError
	 */
	public void doFirstPass() throws AssemblerError
	{
		int line = 1;
		String filename = "<unknown>";
		try {
		boolean replaceToken = true;
		tokenizedSource.offer(null);
		while(true)
		{
			String token = tokenizedSource.pop();
			
			if (token == null)
				break;
			
			if (token.equals("\n"))
			{
				line++;
				continue;
			}
			
			if (token.charAt(0) == '\t')
			{
				filename = token.substring(1);
				continue;
			}
			
			switch(token)
			{
			case ".text":
				switchSeg(0);
				continue;
			case ".data":
				switchSeg(1);
				continue;
			case ".ktext":
				switchSeg(2);
				continue;
			case ".kdata":
				switchSeg(3);
				continue;
			case ".const":
				String name = tokenizedSource.get(0);
				String strVal = tokenizedSource.get(1);
				if (name != null && strVal != null)
				{
					try
					{
						symTbl.put(name, Integer.parseInt(strVal));
					}
					catch (Exception e)
					{
					throw new AssemblerError(ErrorID.CONST_NOT_INTEGER);
					}
				}
				replaceToken = false;
				tokenizedSource.pop(); //Remove the name and value
				tokenizedSource.pop(); //from the token stream, too.
				break;
				
			}
			
			if (token.lastIndexOf(':') == token.length() - 1)
			{
				//Looks like we've found a label
				//Add it to the symbol table
				token = token.substring(0, token.length() - 1);
				switch (currentSeg)
				{
				case 0: 
					symTbl.put(token, Memory.TEXT_SEGMENT_START_ADDRESS + (LC[currentSeg] << 2));
					break;
				case 1:
					symTbl.put(token, Memory.DATA_SEGMENT_START_ADDRESS + LC[currentSeg]);
					break;
				case 2:
					symTbl.put(token, Memory.KTEXT_SEGMENT_START_ADDRESS + (LC[currentSeg] << 2));
					break;
				case 3:
					symTbl.put(token, Memory.KDATA_SEGMENT_START_ADDRESS + LC[currentSeg]);
					break;
				}
				continue;
			}
			
			if (currentSeg % 2 == 0) //text, ktext
			{
				if (InstructionSet.contains(token))
					LC[currentSeg]++;
				else if (PseudoInstructionSet.contains(token))
				{
					ArrayList<String> methodSig = new ArrayList<>();
					methodSig.add(token);
					for(int i = 0; ! tokenizedSource.get(i).equals("\n"); i++)
					{
						String arg = tokenizedSource.get(i).replace(',', ' ').trim();
						int argImmVal = 0;
						/*
						 * VERY simple heuristic to check whether argument is a register.
						 * TODO: Write something more robust if this gives us problems.
						 */
						if (arg.indexOf('$') != -1)
							methodSig.add("reg");
						else 
						{
							methodSig.add(isInt32(arg) ? "int32" : "int16");
						}

					}
					LC[currentSeg] += PseudoInstructionSet.getInstructionLength(Arrays.toString(methodSig.toArray()));
					System.out.println(Arrays.toString(methodSig.toArray()));
				}
					
			}
			else //data, kdata
			{
				replaceToken = false;
				byte[] result = new byte[1];
				//TODO: handle each directive with its own function, which may throw an AssemblerException; catch this exception, etc.
				switch(token)
				{
				case ".asciiz":
					result = compileAscii(tokenizedSource.pop(), true);
					break;
				case ".ascii":
					result = compileAscii(tokenizedSource.pop(), false);
					break;
				case ".align":
					int amount;
					try
					{	amount = Integer.parseInt(tokenizedSource.pop()); }
					catch (Exception e)
					{	throw new AssemblerError(ErrorID.ALIGN_ARG_NOT_INTEGER); }
					
					if (amount < 0 || amount > 3)
						throw new AssemblerError(ErrorID.ALIGN_ARG_INVALID);
					
					if (amount == 0)
						break;
					
					amount = (1 << amount); //eg. amount = 2^amount
					result = new byte[amount - (dataSegs.get(currentSeg / 2).size() % amount)];

					break;
				case ".space":
					int space;
					try
					{	space = Integer.parseInt(tokenizedSource.pop()); }
					catch (Exception e)
					{	throw new AssemblerError(ErrorID.SPACE_ARG_INVALID); }
					
					if (space < 0)
						throw new AssemblerError(ErrorID.SPACE_NEGATIVE);
					
					result = new byte[space];
					break;
				default:
					throw new AssemblerError(ErrorID.DATA_SEG_DIRECTIVE_INVALID);
				}
				for(int i = 0; i < result.length; i++)
				{
					dataSegs.get(currentSeg / 2).add(result[i]);
					LC[currentSeg]++;
				}
			}
			
			if (replaceToken)
				tokenizedSource.offer(token);
			replaceToken = true;
			
		}
		
		/*
		 * Start debugging code.
		 */
		
		System.out.println("---------------ASSEMBLY RESULTS-----------------");
		System.out.println("SYMBOL TABLE:");
		for(String s : symTbl.keySet())
		{
			System.out.println("\t" + s + "\t\t\t" + (symTbl.get(s)));
		}
		System.out.println("COMPILED DATA SEGMENT:");
		System.out.println(Arrays.toString(dataSegs.get(0).toArray(new Byte[1])));
				
		/*
		 * End debugging code.
		 */
		
		} catch (AssemblerError e)
		{
			e.setFileInformation(filename, line);
			throw e;
		}
	}
	
	
	
	/**
	 * Escapes a string and converts it into a byte array.
	 * The escape characters are those supported by Java,
	 * viz. \b, \t, \n, \r, \f, \\, \", and \'.
	 * This method is very lenient: if an escape sequence is
	 * not recognized, it is placed verbatim into the byte array.
	 * Likewise, a backslash at the very end of a string will be put
	 * into the array.
	 * @param ascii the Java String to be converted
	 * @param z whether the string is to be null-terminated
	 * @return an array of bytes representing the String in UTF-8 format
	 */
	private static byte[] compileAscii(String ascii, boolean z)
	{
		ArrayList<Byte> escapedString = new ArrayList<>();
		for(int i = 0; i < ascii.length(); i++)
		{
			char ch = ascii.charAt(i);
			if (ch == '\\')
			{
				if (i == ascii.length() - 1)
				{
					escapedString.add((byte)(0xFF & ch));
					break;
				}
				else
				{
					switch(ascii.charAt(i + 1))
					{
					case 't':
						escapedString.add((byte)(0xFF & '\t'));
						break;
					case 'b':
						escapedString.add((byte)(0xFF & '\b'));
						break;
					case 'n':
						escapedString.add((byte)(0xFF & '\n'));
						break;
					case 'r':
						escapedString.add((byte)(0xFF & '\r'));
						break;
					case 'f':
						escapedString.add((byte)(0xFF & '\f'));
						break;
					case '\\':
						escapedString.add((byte)(0xFF & '\\'));
						break;
					case '\"':
						escapedString.add((byte)(0xFF & '\"'));
						break;
					case '\'':
						escapedString.add((byte)(0xFF & '\''));
					default:
						escapedString.add((byte)(0xFF & ch));
						i--;
						continue;
					}
					i++;
				}
			}
			else
				escapedString.add((byte)(0xFF & ch));
		}
		if (z)
			escapedString.add((byte) 0);
		
		byte[] result = new byte[escapedString.size()];
		for(int i = 0; i < result.length; i++)
			result[i] = escapedString.get(i);
		
		return result;
		
	}
	
	/**
	 * 
	 * @param arg
	 * @return
	 * @throws AssemblerError
	 */
	public boolean isInt32(String arg) throws AssemblerError
	{
		int immVal;
		char[] operators = {'+', '-', '/', '*', '[', ']'};
		int[] opPositions = new int[operators.length];
		
		/*
		 * First, parse postfixes.
		 * Resolve labels if necessary.
		 * Goal:
		 * 		label[LO]+65536[HI]+2*3/label2 ->
		 * 		44+1+2*3/label2
		 */
		int last = 0;
		while(arg.indexOf('[') != -1)
		{
			int val = 0;
			
			String postfix = arg.substring(arg.indexOf('['), arg.indexOf(']'));
			if ( ! (postfix.equals("[HI]") || postfix.equals("[LO]")))
				throw new AssemblerError(ErrorID.LITERAL_POSTFIX_INVALID, postfix);
			
			String literal = arg.substring(last, arg.indexOf('['));
			for(int i = 0; i < opPositions.length; i++)
				opPositions[i] = literal.indexOf(operators[i]);
			int a = findMin(opPositions);
			while(a != -1)
			{
				literal = literal.substring(opPositions[a]);
				opPositions[a] = literal.indexOf(operators[a]);
				a = findMin(opPositions);
			}
			
			try
			{
				val = Integer.parseInt(literal);
			}
			catch (NumberFormatException e)
			{
				Integer symbol = symTbl.get(val);
				if (symbol == null) 
					symbol = Memory.TEXT_SEGMENT_START_ADDRESS;
			}
		}
		
		return false;
		/*
		char[] operators = {'+', '-', '/', '*', '[', ']'};
		int[] opPositions = new int[operators.length];
		for(int i = 0; i < opPositions.length; i++)
			opPositions[i] = arg.indexOf(operators[i]);
		while(findMin(opPositions) != -1)
		{
			
		}
		
		return false;
		*/
		
		/*
		if (opPositions[4] != -1)
		{
			if (opPositions[5] - opPositions[4] < 0)
				throw new AssemblerError(4);
			
			String postfix = arg.substring(opPositions[4], opPositions[5]);
			if ( ! (postfix.equals("[HI]") || postfix.equals("[LO]")))
				throw new AssemblerError(5, postfix);
			return false;
		}
		
		int argImmVal;
		String postfix = "";
		try
		{	
			int hasPostfix = arg.indexOf('[');

			
		}
		catch (AssemblerError e)
		{
			throw e;
		}
		catch (NumberFormatException e)
		{
			throw new AssemblerError(4);
		}
		
		return immVal;
		*/
	}
	
	/**
	 * Returns the index of the lowest element of an array
	 * which is not equal to -1. If all elements of the array
	 * are equal to -1, return -1.
	 * @param a an array of integers
	 * @return see above
	 */
	private int findMin(int[] a)
	{
		int result = 0;
		int min = Integer.MAX_VALUE;
		for(int i = 0; i < a.length; i++)
		{
			if (a[i] == -1)
				continue;
			if (a[i] < min)
			{
				min = a[i];
				result = i;
			}
		}
		return min == Integer.MAX_VALUE ? -1 : result;
	}
	
	/**
	 * Switches the current segment.
	 * If the segment we're trying to switch to has
	 * already been assembled, assembler error #0 is thrown.
	 * @param toWhich the new segment
	 * @throws AssemblerError if segment was already completed
	 */
	private static void switchSeg(int toWhich) throws AssemblerError
	{
		if (segComplete[toWhich])
			throw new AssemblerError(ErrorID.SEG_DECLARED_TWICE);
		segComplete[currentSeg] = true;
		currentSeg = toWhich;
	}
		
}
